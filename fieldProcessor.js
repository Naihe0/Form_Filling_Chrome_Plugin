// ========================================================================
// == FIELD PROCESSOR                                                  ==
// ========================================================================
// This object encapsulates the logic for processing a single form field.
// It is designed to be called from the main content script.

const FieldProcessor = {
    // These will be initialized by the main agent
    statusUI: null,
    successfully_filled_fields: null,
    askLLM: null,

    /**
     * Initializes the FieldProcessor with necessary dependencies from the calling agent.
     * @param {object} agentContext - The context from the FormFillerAgent.
     * @param {StatusUI} agentContext.statusUI - The UI handler for status updates.
     * @param {Set<string>} agentContext.successfully_filled_fields - A set of selectors for already filled fields.
     * @param {function} agentContext.askLLM - The function to communicate with the LLM.
     */
    init(agentContext) {
        this.statusUI = agentContext.statusUI;
        this.successfully_filled_fields = agentContext.successfully_filled_fields;
        this.askLLM = agentContext.askLLM;
    },

    /**
     * Processes a single field: finds the element, handles ambiguity, executes the action,
     * and retries with LLM correction on failure.
     * @param {object} field - The field object from the LLM.
     * @param {string} value - The value to fill in.
     * @param {object} profile - The user's profile data.
     */
    async processSingleField(field, value, profile) {
        let { selector, action, question } = field;
        const MAX_RETRIES = 2;
        let lastError = null;
        let elementToProcess = null;

        // --- Ambiguity Resolution ---
        try {
            const potentialElements = Array.from(document.querySelectorAll(selector));

            if (potentialElements.length > 1) {
                console.log(`[Ê≠ß‰πâÂ§ÑÁêÜ] ÈÄâÊã©Âô® "${selector}" ÂåπÈÖçÂà∞ ${potentialElements.length} ‰∏™ÂÖÉÁ¥†„ÄÇÂ∞ÜÈÄöËøáÈóÆÈ¢òÊñáÊú¨ "${question}" ËøõË°åÁ≤æÁ°ÆÂÆö‰Ωç„ÄÇ`);
                
                let minDistance = Infinity;
                let bestElement = null;
                let bestLabel = '';
                const normalize = str => (str || '').replace(/\\s+/g, '').toLowerCase();
                const normQuestion = normalize(question);

                for (const el of potentialElements) {
                    const uniqueElSelector = this.getUniqueSelector(el);
                    if (this.successfully_filled_fields.has(uniqueElSelector)) {
                        continue; // Skip already filled elements
                    }

                    let parent = el.parentElement;
                    let distance = 1;
                    let found = false;
                    let foundLabel = '';
                    while (parent && distance < 10) {
                        const labelText = parent.textContent ? parent.textContent.trim() : '';
                        const normLabel = normalize(labelText);
                        if (normLabel && (normLabel.includes(normQuestion) || normQuestion.includes(normLabel))) {
                            found = true;
                            foundLabel = labelText;
                            break;
                        }
                        parent = parent.parentElement;
                        distance++;
                    }
                    if (found && distance < minDistance) {
                        minDistance = distance;
                        bestElement = el;
                        bestLabel = foundLabel;
                    }
                }
                
                if (bestElement) {
                    console.log(`[Ê≠ß‰πâÂ§ÑÁêÜ] ÈÄâÊã©Ë∑ùÁ¶ªÈóÆÈ¢òÊñáÊú¨ÊúÄËøëÁöÑÂÖÉÁ¥† (Áà∂ËäÇÁÇπÂÜÖÂÆπ: "${bestLabel}")„ÄÇ`);
                    elementToProcess = bestElement;
                }
            } else if (potentialElements.length === 1) {
                elementToProcess = potentialElements[0];
            }

            if (elementToProcess) {
                const uniqueSelector = this.getUniqueSelector(elementToProcess);
                if (this.successfully_filled_fields.has(uniqueSelector)) {
                     console.warn(`[Ê≠ß‰πâÂ§ÑÁêÜ] ÁõÆÊ†áÂÖÉÁ¥† ${uniqueSelector} (ÈóÆÈ¢ò: "${question}") Â∑≤ÁªèË¢´Â°´ÂÖÖËøáÔºåÂ∞ÜË∑≥Ëøá„ÄÇ`);
                     return;
                }
                selector = uniqueSelector;
            }
            
        } catch (e) {
            console.warn(`ÂàùÂßãÈÄâÊã©Âô® "${selector}" Êó†Êïà: ${e.message}`);
        }
        // --- End of Ambiguity Resolution ---

        for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            let element;
            try {
                element = document.querySelector(selector);
            } catch (e) {
                console.error(`[Â∞ùËØï ${attempt}] ÈÄâÊã©Âô® "${selector}" Êó†Êïà:`, e.message);
                lastError = e;
                continue;
            }

            if (!element) {
                lastError = new Error(`Element not found with selector: ${selector}`);
                console.error(`[Â∞ùËØï ${attempt}] Êú™ÊâæÂà∞ÂÖÉÁ¥†: ${selector}`);
                continue;
            }

            // Visual feedback for the user
            element.style.transition = 'all 0.3s';
            element.style.border = '2px solid red';
            element.style.backgroundColor = '#fff0f0';
            element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            await new Promise(r => setTimeout(r, 300));

            try {
                await this.executeAction(element, action, value);
                console.log(`‚úÖ [Â∞ùËØï ${attempt}] ÊàêÂäü: Action '${action}' on '${question}' with selector '${selector}'`);
                
                // Cleanup visual feedback
                element.style.border = '2px solid green';
                element.style.backgroundColor = '#f0fff0';
                await new Promise(r => setTimeout(r, 1000));
                element.style.border = '';
                element.style.backgroundColor = '';

                this.successfully_filled_fields.add(selector);
                return; // Success, exit the function

            } catch (e) {
                lastError = e;
                console.error(`[Â∞ùËØï ${attempt}] Â§±Ë¥•: Action '${action}' on '${question}'. Error:`, e.message);
                element.style.border = '2px solid #b91c1c'; // Darker red for error
            }
        }
        
        console.error(`Â∏∏ËßÑÂ∞ùËØïÊúÄÁªàÂ§±Ë¥•: Action '${action}' on '${question}'. Ê≠£Âú®Ë∞ÉÁî® LLM ËøõË°åÁ∫†Èîô...`);
        
        this.statusUI.update(`ü§î Â≠óÊÆµ "${question}" Â°´ÂÖÖÂ§±Ë¥•ÔºåÂ∞ùËØïÁ∫†Èîô...`);
        const fieldForCorrection = { ...field, selector: selector };
        try {
            const correctedField = await this.correctFieldWithLLM(fieldForCorrection, lastError, profile);

            if (correctedField && correctedField.selector && correctedField.action) {
                this.statusUI.update(`‚úÖ Á∫†ÈîôÊàêÂäüÔºåÊ≠£Âú®ÈáçËØïÂ≠óÊÆµ "${question}"...`);
                console.log("[Á∫†ÈîôÂêéÈáçËØï] ‰ΩøÁî®LLM‰øÆÊ≠£ÂêéÁöÑÊñ∞ÂèÇÊï∞:", correctedField);
                const finalElement = document.querySelector(correctedField.selector);
                if (finalElement) {
                    await this.executeAction(finalElement, correctedField.action, correctedField.value || value);
                    this.successfully_filled_fields.add(correctedField.selector);
                    console.log(`‚úÖ [Á∫†ÈîôÂêé] ÊàêÂäü: Action '${correctedField.action}' on '${question}'`);
                } else {
                    throw new Error("LLM Á∫†ÈîôÂêé‰ªçÁÑ∂Êâæ‰∏çÂà∞ÂÖÉÁ¥†„ÄÇ");
                }
            } else {
                 throw new Error("LLM Á∫†ÈîôÊú™ËÉΩËøîÂõûÊúâÊïàÁöÑÈÄâÊã©Âô®ÊàñÊìç‰Ωú„ÄÇ");
            }
        } catch (correctionError) {
            console.error(`‚ùå Â≠óÊÆµ "${question}" ÂΩªÂ∫ïÂ§±Ë¥•ÔºåLLM Á∫†Èîô‰πüÊó†Êïà:`, correctionError.message);
            this.statusUI.update(`‚ùå Â≠óÊÆµ "${question}" Â°´ÂÖÖÂ§±Ë¥•`);
        }
    },

    /**
     * Executes a specific action (e.g., 'input', 'click') on a given element.
     * @param {HTMLElement} element - The target DOM element.
     * @param {string} action - The action to perform.
     * @param {string} value - The value for the action (if any).
     */
    async executeAction(element, action, value) {
        return new Promise(async (resolve, reject) => {
            try {
                if (action.toLowerCase().includes('click') || element.tagName === 'BUTTON' || element.type === 'button' || element.type === 'submit' || element.role === 'button') {
                    element.focus();
                    element.click();
                    // For clicks, especially on custom elements, we need to verify success
                    if (!await this.verifyClickSuccess(element)) {
                        console.warn("ÂàùÊ≠•ÁÇπÂáªÂèØËÉΩÊú™ÊàêÂäüÔºåÂ∞ùËØïÊ®°ÊãüÂéüÁîü‰∫ã‰ª∂...");
                        const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });
                        element.dispatchEvent(clickEvent);
                    }
                } else if (action.toLowerCase().includes('select') || element.tagName === 'SELECT') {
                    element.focus();
                    let optionFound = false;
                    // Try to find by value first
                    for (let opt of element.options) {
                        if (opt.value === value || opt.text.includes(value)) {
                            opt.selected = true;
                            optionFound = true;
                            break;
                        }
                    }
                    if (!optionFound) {
                         console.warn(`Âú® <select> ‰∏≠Êú™ÊâæÂà∞ÂÄº "${value}"`);
                    }
                    element.dispatchEvent(new Event('change', { bubbles: true }));
                } else { // Default to input
                    element.focus();
                    element.value = value;
                    element.dispatchEvent(new Event('input', { bubbles: true }));
                    element.dispatchEvent(new Event('change', { bubbles: true }));
                }
                resolve();
            } catch (e) {
                reject(e);
            }
        });
    },

    /**
     * Verifies if a click action was successful, especially for custom UI elements.
     * @param {HTMLElement} element - The element that was clicked.
     * @returns {Promise<boolean>} - True if the click seemed successful.
     */
    async verifyClickSuccess(element) {
        // A simple heuristic: check if the element is still visible and enabled.
        // A more complex check could involve observing DOM mutations.
        return new Promise(resolve => {
            setTimeout(() => {
                const style = window.getComputedStyle(element);
                const isVisible = style.display !== 'none' && style.visibility !== 'hidden' && element.offsetParent !== null;
                resolve(isVisible && !element.disabled);
            }, 500); // Wait a bit for UI to update
        });
    },

    /**
     * Asks the LLM to correct a failed field-filling attempt.
     * @param {object} originalField - The field that failed.
     * @param {Error} error - The error that occurred.
     * @param {object} profile - The user's profile.
     * @returns {Promise<object|null>} - A corrected field object or null.
     */
    async correctFieldWithLLM(originalField, error, profile) {
        console.log("[Á∫†ÈîôÊ®°Âºè] ÂáÜÂ§áÂêë LLM ËØ∑Ê±Ç‰øÆÊ≠£ÊñπÊ°à...");
        let htmlContext = '';

        console.log(originalField);
        // Â∞ùËØïÁî®ÈóÆÈ¢òÊñáÊú¨Âú®Êï¥‰∏™body‰∏≠ÂÆö‰Ωç‰∏ä‰∏ãÊñá
        console.log('[Á∫†ÈîôÊ®°Âºè] ‰ΩøÁî®ÂÖ≥ËÅîÁöÑHTMLÂùóÊàñÈóÆÈ¢òÊñáÊú¨ÂÆö‰Ωç‰∏ä‰∏ãÊñá„ÄÇ');
        if (originalField.question) {
            const bodyHtml = document.body.outerHTML;
            const idx = bodyHtml.indexOf(originalField.question);
            console.log(`ÈóÆÈ¢òÊñáÊú¨ "${originalField.question}" Âú®body‰∏≠Á¥¢Âºï‰ΩçÁΩÆ: ${idx}`);
            if (idx !== -1) {
                const start = Math.max(0, idx - 2000);
                const end = Math.min(bodyHtml.length, idx + originalField.question.length + 2000);
                htmlContext = bodyHtml.substring(start, end);
                console.log('[Á∫†ÈîôÊ®°Âºè] ÈÄöËøáÈóÆÈ¢òÊñáÊú¨Âú®body‰∏≠ÂÆö‰ΩçÂà∞‰∏ä‰∏ãÊñáÔºåÂπ∂Êà™ÂèñÈóÆÈ¢òÊñáÊú¨‰∏ä‰∏ã2000Â≠óÁ¨¶„ÄÇ');
            }
        }

        if (!htmlContext) {
            try {
                const element = document.querySelector(originalField.selector);
                if (element) {
                    htmlContext = this.getSurroundingHtml(element);
                    console.log('[Á∫†ÈîôÊ®°Âºè] ‰ΩøÁî®ÈÄâÊã©Âô®ÂÆö‰ΩçÂÖÉÁ¥†Âπ∂Ëé∑ÂèñÂÖ∂Âë®ËæπHTML‰Ωú‰∏∫‰∏ä‰∏ãÊñá„ÄÇ');
                } else {
                    throw new Error('Element not found via selector');
                }
            } catch (e) {
                console.log(`[Á∫†ÈîôÊ®°Âºè] Êó†Ê≥ïÈÄöËøáÈÄâÊã©Âô® \"${originalField.selector}\" ÂÆö‰ΩçÂÖÉÁ¥†Ôºå‰∏îÊú™ÊâæÂà∞ÂÖ≥ËÅîÁöÑHTMLÂùó„ÄÇÂ∞ÜÂèëÈÄÅÊï¥‰∏™ body HTML ‰Ωú‰∏∫‰∏ä‰∏ãÊñá„ÄÇ`);
                htmlContext = this.getVisibleHtml(); // Use the cleaned full HTML
            }
        }

        // Truncate context if it's too long
        if (htmlContext.length > 15000) {
            console.warn(`[Á∫†ÈîôÊ®°Âºè] HTML ‰∏ä‰∏ãÊñáËøáÈïø (${htmlContext.length} chars)ÔºåÂ∞ÜÊà™Êñ≠‰∏∫ 15000 Â≠óÁ¨¶„ÄÇ`);
            htmlContext = htmlContext.substring(0, 15000);
        }

        console.log("[Á∫†ÈîôÊ®°Âºè] ÂèëÈÄÅÁªôLLMÁöÑHTML‰∏ä‰∏ãÊñá:", htmlContext); // Log snippet

        const prompt = `
            ‰Ω†ÊòØ‰∏Ä‰∏™WebËá™Âä®Âåñ‰∏ìÂÆ∂„ÄÇ‰∏Ä‰∏™Ëá™Âä®ÂåñËÑöÊú¨Âú®ÁΩëÈ°µ‰∏äÂ°´ÂÖÖÂ≠óÊÆµÊó∂ÂèØËÉΩÂ§±Ë¥•‰∫Ü„ÄÇ
            Â§±Ë¥•ÁöÑÂ≠óÊÆµ‰ø°ÊÅØ:
            - ÈóÆÈ¢ò: \"${originalField.question}\"
            - Â∞ùËØïÁöÑCSSÈÄâÊã©Âô®: \"${originalField.selector}\"
            - Â≠óÊÆµÁ±ªÂûã: \"${originalField.action}\"

            ËøôÊòØËØ•Â≠óÊÆµÁõ∏ÂÖ≥ÁöÑHTML‰∏ä‰∏ãÊñá:
            \`\`\`html
            ${htmlContext}
            \`\`\`

            Áî®Êà∑‰∏™‰∫∫ËµÑÊñôÂ¶Ç‰∏ã:
            \`\`\`json
            ${JSON.stringify(profile, null, 2)}
            \`\`\`

            ËØ∑ÂàÜÊûêHTMLÂπ∂Êèê‰æõ‰∏Ä‰∏™‰øÆÊ≠£ÊñπÊ°à„ÄÇ‰Ω†ÈúÄË¶ÅËøîÂõû‰∏Ä‰∏™JSONÂØπË±°ÔºåÂÖ∂‰∏≠ÂåÖÂê´‰∏Ä‰∏™JSËÉΩÁÇπÂáªÁöÑCSSÈÄâÊã©Âô®„ÄÇ
            Â¶ÇÊûúÂéüÂßãÈÄâÊã©Âô®ÊòØÈîôËØØÁöÑÔºåËØ∑Êèê‰æõ "newSelector"„ÄÇ
            Â¶ÇÊûúÂ≠óÊÆµÊòØÂçïÈÄâÊåâÈíÆÊàñÂ§çÈÄâÊ°ÜÔºåËØ∑Á°Æ‰øùÈÄâÊã©Âô®ÂÆö‰ΩçÂà∞Áî®Êà∑ËµÑÊñôÂåπÈÖçÁöÑÁâπÂÆöÈÄâÈ°π„ÄÇ
            Â¶ÇÊûúÂéüÂßãÈÄâÊã©Âô®ÂÖ∂ÂÆûÊòØÊ≠£Á°ÆÁöÑÔºå‰ΩÜÂèØËÉΩÂõ†‰∏∫Êó∂Êú∫ÈóÆÈ¢òÊàñÈ°µÈù¢Âä®ÊÄÅÂèòÂåñËÄåÂ§±Ë¥•ÔºåÂàôËøîÂõûÂéüÂßãÈÄâÊã©Âô®„ÄÇ
            Â¶ÇÊûúÂéüÂßãÈÄâÊã©Âô®ÂÖ∂ÂÆûÊòØÊ≠£Á°ÆÁöÑÔºåÂπ∂‰∏î‰πüÁÇπÂáªÊàêÂäü‰∫ÜÔºåÂàôËøîÂõûÁ©∫„ÄÇ

            ËøîÂõûÊ†ºÂºèÂøÖÈ°ªÊòØ:
            {
              "newSelector": "<correct_css_selector>"
            }
        `;

        try {
            const response = await this.askLLM(prompt, 'gpt-4.1-turbo');
            const correctedJson = JSON.parse(response);
            console.log("[Á∫†ÈîôÊ®°Âºè] LLMËøîÂõûÁöÑ‰øÆÊ≠£ÊñπÊ°à:", correctedJson);

            if (correctedJson && correctedJson.newSelector) {
                return { ...originalField, selector: correctedJson.newSelector };
            } else {
                console.error("[Á∫†ÈîôÊ®°Âºè] LLMÊú™ËÉΩÊèê‰æõÊúâÊïàÁöÑ‰øÆÊ≠£ÈÄâÊã©Âô®„ÄÇ");
                return null;
            }
        } catch (e) {
            console.error("[Á∫†ÈîôÊ®°Âºè] Ë∞ÉÁî®LLMËøõË°åÁ∫†ÈîôÊó∂ÂèëÁîü‰∏•ÈáçÈîôËØØ:", e);
            return null;
        }
    },

    // --- DOM HELPER FUNCTIONS ---

    /**
     * Generates a unique CSS selector for a given element.
     * @param {HTMLElement} el - The element.
     * @returns {string} A unique selector.
     */
    getUniqueSelector(el) {
        if (!(el instanceof Element)) return;
        let path = [];
        while (el.nodeType === Node.ELEMENT_NODE) {
            let selector = el.nodeName.toLowerCase();
            if (el.id) {
                selector += '#' + el.id;
                path.unshift(selector);
                break;
            } else {
                let sib = el, nth = 1;
                while (sib = sib.previousElementSibling) {
                    if (sib.nodeName.toLowerCase() == selector)
                       nth++;
                }
                if (nth != 1)
                    selector += ":nth-of-type("+nth+")";
            }
            path.unshift(selector);
            el = el.parentNode;
        }
        return path.join(" > ");
    },

    /**
     * Gets the HTML content surrounding a given element.
     * @param {HTMLElement} element - The element.
     * @param {number} radius - The character radius to search for.
     * @returns {string} The surrounding HTML.
     */
    getSurroundingHtml(element, radius = 2000) {
        let parent = element.parentElement;
        if (!parent) return element.outerHTML;

        // Go up to find a parent that contains a decent chunk of HTML
        while (parent && parent.outerHTML.length < radius && parent.tagName !== 'BODY') {
            element = parent;
            parent = parent.parentElement;
        }
        
        return element.outerHTML;
    },

    /**
     * Gets all visible HTML from the body.
     * @returns {string} The visible HTML.
     */
    getVisibleHtml() {
        // Clones the document body, removes script/style tags, and returns the outer HTML.
        const bodyClone = document.body.cloneNode(true);
        bodyClone.querySelectorAll('script, style, noscript').forEach(el => el.remove());
        return bodyClone.outerHTML;
    }
};
